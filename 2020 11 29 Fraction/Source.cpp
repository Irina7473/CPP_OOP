#include<iostream>
#include <fstream>
#include <cstdlib>
#include"Class_Fraction.h"
using namespace std;

void main()
{
	setlocale(LC_ALL, "Russian");
//#define CONSTRUCTORS_CHECK

#ifdef CONSTRUCTORS_CHECK
	Fraction A;	//Default constructor
	A.print();
	A.print_address();

	Fraction B = 5;//Single argument constructor
	B.print();
	B.print_address();

	Fraction C(1, 2);
	C.print();
	C.print_address();

	Fraction D(2, 3, 4);
	D.print();
	D.print_address();
#endif // CONSTRUCTORS_CHECK

//#define arifmetic check
#ifdef arifmetic check


	Fraction A(2, 3, 4);
	Fraction B(5, 7, 8);
	Fraction C;
	C = A / B;
	C.print();
	A /= B;
	A.print();
#endif arifmetic check
	
	/*
	Fraction A(3, 4);
	Fraction B(1, 4);
	Fraction C = A - B;
	C.print();
	C /= B;
	cout << C << endl;*/
	
	/*
	Fraction i(1, 2);
	Fraction j;
	j= ++i;
	i.print();
	j.print();
	j = i++;
	i.print();
	j.print();
	*/

	/*
	double a = 2.5;
	cout << a << (int)a << int(a);
	cout << typeid(2 + 3.5).name();

	int a = 2;    //нет преобразования
	double b = 3;  //есть преобразование
	*/
	Fraction A = (Fraction)5;  //есть преобразованиеб но нужен конструктор с 1 параметром
	Fraction B;
	B =(Fraction) 8;
	Fraction C(2, 5, 10);
	double d = C;
	cout << A << B << C<<d;









}


	/*
	int a, b, c;
	a = b = c = 0;

	Fraction A, B, C;
	cout << "\n---------------------------------------\n";
	A = B = C = Fraction(1, 2, 3);
	cout << "\n---------------------------------------\n";

	//Fraction A(3, 4);
	//A.print();
	//Fraction B(4, 5);
	//B.print();
	//Fraction C;
	//C = A;	//CopyAssignment (operator=)
	//C.print();
}*/


/*
---------------------------------
		Overloading rules:
1. Перегрузить можно только СУЩЕСТВУЮЩИЕ операторы
	+	перегружается
	++	перегружается
	*	перегружается
	**	НЕ перегружается
2. НЕ все существующие оперторы можно перегрузить. Не перегружаются
	?: - тернарный оператор;
	.  - оператор прямого доступа;
	.*
	:: - оператор разрешения видимости
	#
	##
3. Перегруженные оперторы сохраняют приоритет;
4. Нельзя изменить поведение операторов со свтроенными типами.
---------------------------------
*/



/*компилятор все значения преобразует к наибольшему типу данных в ввыражении
кроме присваивания =
присвоить всегда преобразует значение справа к типу слева
независимо от пеотери данных если эти два типа преобрзуются

в ооп различают преобразования из другого типа в наш и из нашего в ругие типы

преобразование других типов в наш тип
для этого в классе дб конструктор с 1 параметром
туту участвует оператор присваивания
для запрета неявных преобразований перед конструктором нжно написать ключевое слво explisit

преобразование нашего типа в другие типы
для этого нужны операторы преобразования типов
оператор преобразования - это обычная функция ,  имя которой состоит
из ключего слова и имени существующего типа 
операторы преобразования никогда и ничего не принимают, если перегружаются внутри класса
ему и так понятно, что нужно преобразовать
в операторах преобразования также не пишется тип возвращаемого значения


explisit нужен для запрета неявных преобразований
если он присутствуетв одном из операторов преобразования, то везде лучше его указать, во всех

*/